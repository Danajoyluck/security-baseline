# Introduction
## Context and Scope
This document is the second part of the OpenSSF technology consumption architecture series. It captures the open source technologies that are hosted in OpenSSF, provided by Google, CNCF and source control management systems(SCM). Building on top of the technologies introduced in [open source software dependency management](./consumption-architecture-dependency-management.md), this document expands on  OSS security technologies and ecosystem supports that make software supply chain more secure through vulnerability management. 

The goals of this document are:
- To help open source software producers discover, adopt as appropriate, and contribute to technical initiatives of OpenSSF (and related foundations) to improve vulnerability management. 
- To provide an easy model for our end user organizations large and small to have a framework/reference architecture to help them manage vulnerabilities using open source technologies. 

Vulnerabilities in an open source software and its dependencies are in the scope of this document. This document serves as a map that takes readers from here to OpenSSF and adjacent technologies. Details of the open source technologies are out of the scope of this document. How consumers manage vulnerabilities is out of the scope of this document.   

This document is inspired and based on the previous work conducted by open source maintainers, contributors and community members.  

## Intended Audience
Open source software maintainers, contributors and consumers are the intended audience of this document. If you are new to OpenSSF or CNCF technologies, we encourage reading [Consumption Architecture for Open Source Dependency Management](./consumption-architecture-dependency-management.md) before reading this article to get a glimpse into those technologies.  

The document answers these questions:
- As an open source software producer, I'd like to produce more secure open source software. What OpenSSF resources can I leverage to manage vulnerabilities in my own code and dependencies? 
- As an open source software consumer, I'd like to consume secure open source software. What resources does OpenSSF provide for vulnerability management? 
- As an open source software producer and a consumer, I'd like to contribute to open source security technologies for vulnerability management. Where do I start? 

## Nomenclature
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

# Open Source Software Vulnerability Management 

As we discussed in [open source software dependency management](./consumption-architecture-dependency-management.md#open-source-software-dependency-management), open source software is the foundation of the digital world we live in. Managing software dependency is one aspect of vulnerability management. It is critical to manage all aspects of open source software vulnerability in order to sustain open source software security and reliability. OpenSSF has established a [security baseline](https://github.com/ossf/tac/blob/main/process/security_baseline.md) to help minimize vulnerabilities as a software project goes through the development lifecycle. 

The next few sections will dive deeper into these topics to answer OSS producers' and consumers' questions about vulnerability management: 
- [Vulnerability Prevention](#vulnerability-prevention)
- [Asset Inventory](#asset-inventory)
- [Vulnerability Discovery in Your Own Code and Fix](#vulnerability-discovery-in-your-own-code-and-fix)
- [Publicly Known Vulnerability Exploitability and Patching](#publicly-known-vulnerability-exploitability-and-patching)
- [Coordinate Vulnerability Disclosure](#coordinate-vulnerability-disclosure)

## Vulnerability Prevention
Preventing vulnerabilities from happening at the very beginning of the software development life cycle is critical, during the requirement phase, design and initial implementation. Make sure security requirements are clearly documented and well understood. Once design and develop has started, these guidelines will help:
- A memory-safe language is adopted for new projects or new components, in order to reduce memory safety vulnerabilities at scale. [OpenSSF Memory Safety Special Interest Group (SIG)](https://github.com/ossf/Memory-Safety) has best practices and guides for adopting memory-safe languages.
- Two-factor authentication (2FA) is enabled for repository interactive access. This will reduce the risks of credential compromise and attacks on the digital assets.
- There are no hard-coded active secrets in the project source repository. OpenSSF has enabled secret scanning for all the repositories to detect hard-coded secretes to prevent unauthorized access to repository assets.
- Credentials are provisioned with minimal permissions. This minimizes security risks by only granting necessary access to reduce potential attack surfaces, whether it's interactive access or programmatic access in your CI/CD pipeline.
- Merging code into the main branch requires two-people review/approval and all CI/CD status checks passing. This is to reduce the risks of malicious code injection into the repo, and unintentional errors that impact system availability.
- Source repository is free of generated executable artifacts. This is to eliminate the risks of maliciously subverted executables, ensure that generated executables are reproducible from source code.
- GitHub actions and workflows, if any, are set up securely and remain secure. This reduces the risk of repository compromise introduced by malpractices in CI/CD pipeline.
- Data in transit must be protected by cryptographic means. This is to protect data from unauthorized access, ensure data integrity, confidentiality and availability.
- Architecture design is created with up-to-date security controls. This enhances the software security posture and reduces vulnerabilities.

Any software is only as secure as its most vulnerable dependencies, these OpenSSF guidelines help with managing open source software dependencies:
- A dependencies policy is published, maintained and followed. The policy sets clear guidelines for selecting and maintaining secure dependencies.
- Direct dependencies are pinned in internet or infrastructure services and applications your project provides. This ensures that only a known safe version of a dependency is used to protect against malware and credential compromise.
  
Readers will find details of recommended implementation and verification of above security guidelines in these documents:
- [Security Baseline - Once Sandbox](https://github.com/ossf/tac/blob/main/process/security_baseline.md#security-baseline---once-sandbox)
- [Security Baseline - To Become Incubating](https://github.com/ossf/tac/blob/main/process/security_baseline.md#security-baseline---to-become-incubating)
- [Security Baseline - Once Incubating](https://github.com/ossf/tac/blob/main/process/security_baseline.md#security-baseline---once-incubating)

## Asset Inventory 
The increasing number of high-risk vulnerabilities in open source is alarming, as shown in [dependency management article](consumption-architecture-dependency-management.md#open-source-software-dependency-management). We MUST know our assets before we are able to protect them. Building an asset inventory, enriching metadata for those assets and their dependencies is a critical component in effective vulnerability management and incident response. 

For an open source software that has been adopted, and software release artifacts are created, SBOM SHALL be generated and distributed as a release artifact. SBOMs will provide accurate and complete inventory of the software version, license, dependencies and vulnerabilities to enhance supply chain security, in both human and machine processable format. Generating quality SBOMs is a challenge. OpenSSF (bomctl)[https://github.com/bomctl] is addressing the challenge. 

For open source projects, we have some ways to go building a comprehensive asset inventory. GUAC plays a key role in serving the purposes of asset inventory. After a project is onboarded to [GUAC](https://github.com/guacsec/guac), GUAC provides security insights into the project, as demonstrated in [Security Insights into OSS Projects](./consumption-architecture-dependency-management.md#security-insights-into-oss-projects). GUAC has the ability to do reverse lookup - given a publicly know vulnerability identifier, GUAC is able to identify the open source projects that are exploitable by the vulnerability.   

For more information on IT asset inventory, [Palo Alto Networks article](https://www.paloaltonetworks.com/cyberpedia/what-is-it-asset-inventory) can be referenced. 

## Vulnerability Discovery in Your Own Code and Fix
As a project goes through the software development life cycle and being maintained, it requires constant effort to discover vulnerabilities in the code you write, fix it and release it when applicable. OpenSSF provides a few guidelines to reduce those vulnerabilities:
- Static code analysis is run in CI/CD pipeline, and critical severity exploitable vulnerabilities MUST be fixed promptly. This is to identify vulnerabilities in the codebase you develop, and remediate critical vulnerabilities that are exploitable, ensure your project is adoptable. Consider adopting [CodeQL](https://github.com/github/codeql-action#usage) as a Static Application Security Testing(SAST) tool in your CI/CD pipeline.
- [OpenSSF Best Practice Badge](https://www.bestpractices.dev/en/criteria) SUGGESTS that at least one dynamic analysis tool be applied to any proposed major production release of the software before its release.
- [OSS-Fuzz](https://github.com/google/oss-fuzz) runs continuous Fuzzing for open source software. Critical open source software SHOULD be onboarded to OSS-Fuzz. 

## Publicly Known Vulnerability Exploitability and Patching 
Your software is as secure as its weakest dependencies. When the dependencies have publicly known vulnerabilities, you want to check if the vulnerabilities are exploitable in your software before rushing to patch the dependency. Run a thorough risk and impact analysis, have a detailed change implementation plan before execution. An accurate VEX statement with verifiable attestation will serve the purpose. OpenSSF [vexctl](https://github.com/openvex/vexctl) project is in active development and has early adoptions by CNCF on this front.    

To protect your software from known exploitable vulnerabilities, and protect downstream consumers from vulnerable software via transitive dependencies, publicly known vulnerabilities of critical severity in your software SHALL be fixed and released in coordination with project consumers promptly. [Adopt an automatic dependency update tools](https://github.com/ossf/scorecard/blob/7ce8609469289d5f3b1bf5ee3122f42b4e3054fb/docs/checks.md#dependency-update-tool) in your CI/CD helps to actively manage vulnerabilities in your code repository. Leverage [[OSV](https://osv.dev/) to identify and remediate vulnerabilities with accuracy. 

For container images static scan of vulnerabilities, the following is a list of widely-used open source tools that can be adopted in your CI process:
- [Grype](https://github.com/anchore/grype)
  - Scans the contents of a container image or filesystem to find known vulnerabilities.
  - Find vulnerabilities for major operating system packages: Alpine, Amazon Linux, BusyBox, CentOS, CBL-Mariner, Debian, Distroless, Oracle Linux, Red Hat (RHEL), Ubuntu, Wolfi.
  - Find vulnerabilities for language-specific packages:Ruby (Gems), Java (JAR, WAR, EAR, JPI, HPI), JavaScript (NPM, Yarn), Python (Egg, Wheel, Poetry, requirements.txt/setup.py files), Dotnet (deps.json), Golang (go.mod), PHP (Composer), Rust (Cargo)
  - OpenSSF [OpenVEX](https://github.com/openvex) support for filtering and augmenting scanning results.
  - Works with [Syft](https://github.com/anchore/syft), a SBOM (software bill of materials) tool for container images and filesystems.
  - Supports Docker, OCI and Singularity image formats.
- [Trivy](https://aquasecurity.github.io/trivy/v0.17.2/)
  - Scans vulnerabilities in containers, file systems and Git repositories.
  - Detects vulnerabilities in OS packages (Alpine, Red Hat Universal Base Image, Red Hat Enterprise Linux, CentOS, Oracle Linux, Debian, Ubuntu, Amazon Linux, openSUSE Leap, SUSE Enterprise Linux, Photon OS and Distroless) and application dependencies (Bundler, Composer, Pipenv, Poetry, npm, yarn, Cargo, NuGet, Maven, and Go).
- [Clair](https://github.com/quay/clair)
  - Provides [static analysis](https://en.wikipedia.org/wiki/Static_program_analysis) of vulnerabilities in application containers, parsing image contents and reporting vulnerabilities affecting the contents.
  - Extracts contents and assign vulnerabilities from these official base containers: Ubuntu, Debian, RHEL, Suse, Oracle, Alpine, AWS Linux,VMWare Photon, Python.
  - Supports Docker, OCI image formats. 


## Coordinate Vulnerability Disclosure

## Security Audit
If your project provides internet or infrastructure service, a security audit SHALL be conducted before it becomes generally available, and on an as-needed basis following the initial audit. Audit findings SHALL be addressed based on the findings' risk levels. 

# Get Involved
I hope the document makes it a bit easier to explore the OpenSSF land, discover your interested areas, start engaging with various projects and working groups, and find your joy. 



